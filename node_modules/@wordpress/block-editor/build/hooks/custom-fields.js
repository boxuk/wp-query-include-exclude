"use strict";

var _element = require("@wordpress/element");
var _hooks = require("@wordpress/hooks");
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _blocks = require("@wordpress/blocks");
var _compose = require("@wordpress/compose");
var _components2 = require("../components");
var _blockEditingMode = require("../components/block-editing-mode");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Filters registered block settings, extending attributes to include `connections`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function addAttribute(settings) {
  if ((0, _blocks.hasBlockSupport)(settings, '__experimentalConnections', true)) {
    // Gracefully handle if settings.attributes.connections is undefined.
    settings.attributes = {
      ...settings.attributes,
      connections: {
        type: 'object'
      }
    };
  }
  return settings;
}

/**
 * Override the default edit UI to include a new block inspector control for
 * assigning a connection to blocks that has support for connections.
 * Currently, only the `core/paragraph` block is supported and there is only a relation
 * between paragraph content and a custom field.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */
const withInspectorControl = (0, _compose.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEditingMode = (0, _blockEditingMode.useBlockEditingMode)();
    const hasCustomFieldsSupport = (0, _blocks.hasBlockSupport)(props.name, '__experimentalConnections', false);

    // Check if the current block is a paragraph or image block.
    // Currently, only these two blocks are supported.
    if (!['core/paragraph', 'core/image'].includes(props.name)) {
      return (0, _element.createElement)(BlockEdit, {
        ...props
      });
    }

    // If the block is a paragraph or image block, we need to know which
    // attribute to use for the connection. Only the `content` attribute
    // of the paragraph block and the `url` attribute of the image block are supported.
    let attributeName;
    if (props.name === 'core/paragraph') attributeName = 'content';
    if (props.name === 'core/image') attributeName = 'url';
    if (hasCustomFieldsSupport && props.isSelected) {
      return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(BlockEdit, {
        ...props
      }), blockEditingMode === 'default' && (0, _element.createElement)(_components2.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
        title: (0, _i18n.__)('Connections'),
        initialOpen: true
      }, (0, _element.createElement)(_components.TextControl, {
        __nextHasNoMarginBottom: true,
        autoComplete: "off",
        label: (0, _i18n.__)('Custom field meta_key'),
        value: props.attributes?.connections?.attributes?.[attributeName]?.value || '',
        onChange: nextValue => {
          if (nextValue === '') {
            props.setAttributes({
              connections: undefined,
              [attributeName]: undefined,
              placeholder: undefined
            });
          } else {
            props.setAttributes({
              connections: {
                attributes: {
                  // The attributeName will be either `content` or `url`.
                  [attributeName]: {
                    // Source will be variable, could be post_meta, user_meta, term_meta, etc.
                    // Could even be a custom source like a social media attribute.
                    source: 'meta_fields',
                    value: nextValue
                  }
                }
              },
              [attributeName]: undefined,
              placeholder: (0, _i18n.sprintf)('This content will be replaced on the frontend by the value of "%s" custom field.', nextValue)
            });
          }
        }
      }))));
    }
    return (0, _element.createElement)(BlockEdit, {
      ...props
    });
  };
}, 'withInspectorControl');
if (window.__experimentalConnections) {
  (0, _hooks.addFilter)('blocks.registerBlockType', 'core/connections/attribute', addAttribute);
  (0, _hooks.addFilter)('editor.BlockEdit', 'core/connections/with-inspector-control', withInspectorControl);
}
//# sourceMappingURL=custom-fields.js.map