"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withBlockHooks = void 0;
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _hooks = require("@wordpress/hooks");
var _components = require("@wordpress/components");
var _compose = require("@wordpress/compose");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _components2 = require("../components");
var _store = require("../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const EMPTY_OBJECT = {};
function BlockHooksControl(props) {
  const blockTypes = (0, _data.useSelect)(select => select(_blocks.store).getBlockTypes(), []);
  const hookedBlocksForCurrentBlock = (0, _element.useMemo)(() => blockTypes?.filter(({
    blockHooks
  }) => blockHooks && props.blockName in blockHooks), [blockTypes, props.blockName]);
  const {
    blockIndex,
    rootClientId,
    innerBlocksLength
  } = (0, _data.useSelect)(select => {
    const {
      getBlock,
      getBlockIndex,
      getBlockRootClientId
    } = select(_store.store);
    return {
      blockIndex: getBlockIndex(props.clientId),
      innerBlocksLength: getBlock(props.clientId)?.innerBlocks?.length,
      rootClientId: getBlockRootClientId(props.clientId)
    };
  }, [props.clientId]);
  const hookedBlockClientIds = (0, _data.useSelect)(select => {
    const {
      getBlock,
      getGlobalBlockCount
    } = select(_store.store);
    const _hookedBlockClientIds = hookedBlocksForCurrentBlock.reduce((clientIds, block) => {
      // If the block doesn't exist anywhere in the block tree,
      // we know that we have to display the toggle for it, and set
      // it to disabled.
      if (getGlobalBlockCount(block.name) === 0) {
        return clientIds;
      }
      const relativePosition = block?.blockHooks?.[props.blockName];
      let candidates;
      switch (relativePosition) {
        case 'before':
        case 'after':
          // Any of the current block's siblings (with the right block type) qualifies
          // as a hooked block (inserted `before` or `after` the current one), as the block
          // might've been automatically inserted and then moved around a bit by the user.
          candidates = getBlock(rootClientId)?.innerBlocks;
          break;
        case 'first_child':
        case 'last_child':
          // Any of the current block's child blocks (with the right block type) qualifies
          // as a hooked first or last child block, as the block might've been automatically
          // inserted and then moved around a bit by the user.
          candidates = getBlock(props.clientId).innerBlocks;
          break;
      }
      const hookedBlock = candidates?.find(({
        name
      }) => name === block.name);

      // If the block exists in the designated location, we consider it hooked
      // and show the toggle as enabled.
      if (hookedBlock) {
        return {
          ...clientIds,
          [block.name]: hookedBlock.clientId
        };
      }

      // If no hooked block was found in any of its designated locations,
      // but it exists elsewhere in the block tree, we consider it manually inserted.
      // In this case, we take note and will remove the corresponding toggle from the
      // block inspector panel.
      return {
        ...clientIds,
        [block.name]: false
      };
    }, {});
    if (Object.values(_hookedBlockClientIds).length > 0) {
      return _hookedBlockClientIds;
    }
    return EMPTY_OBJECT;
  }, [hookedBlocksForCurrentBlock, props.blockName, props.clientId, rootClientId]);
  const {
    insertBlock,
    removeBlock
  } = (0, _data.useDispatch)(_store.store);

  // Remove toggle if block isn't present in the designated location but elsewhere in the block tree.
  const hookedBlocksForCurrentBlockIfNotPresentElsewhere = hookedBlocksForCurrentBlock?.filter(block => hookedBlockClientIds?.[block.name] !== false);
  if (!hookedBlocksForCurrentBlockIfNotPresentElsewhere.length) {
    return null;
  }

  // Group by block namespace (i.e. prefix before the slash).
  const groupedHookedBlocks = hookedBlocksForCurrentBlock.reduce((groups, block) => {
    const [namespace] = block.name.split('/');
    if (!groups[namespace]) {
      groups[namespace] = [];
    }
    groups[namespace].push(block);
    return groups;
  }, {});
  const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
    switch (relativePosition) {
      case 'before':
      case 'after':
        insertBlock(block, relativePosition === 'after' ? blockIndex + 1 : blockIndex, rootClientId,
        // Insert as a child of the current block's parent
        false);
        break;
      case 'first_child':
      case 'last_child':
        insertBlock(block,
        // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
        relativePosition === 'first_child' ? 0 : innerBlocksLength, props.clientId,
        // Insert as a child of the current block.
        false);
        break;
    }
  };
  return (0, _element.createElement)(_components2.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
    className: "block-editor-hooks__block-hooks",
    title: (0, _i18n.__)('Plugins'),
    initialOpen: true
  }, Object.keys(groupedHookedBlocks).map(vendor => {
    return (0, _element.createElement)(_element.Fragment, {
      key: vendor
    }, (0, _element.createElement)("h3", null, vendor), groupedHookedBlocks[vendor].map(block => {
      const checked = (block.name in hookedBlockClientIds);
      return (0, _element.createElement)(_components.ToggleControl, {
        checked: checked,
        key: block.title,
        label: (0, _element.createElement)(_components.__experimentalHStack, {
          justify: "flex-start"
        }, (0, _element.createElement)(_components2.BlockIcon, {
          icon: block.icon
        }), (0, _element.createElement)("span", null, block.title)),
        onChange: () => {
          if (!checked) {
            // Create and insert block.
            const relativePosition = block.blockHooks[props.blockName];
            insertBlockIntoDesignatedLocation((0, _blocks.createBlock)(block.name), relativePosition);
            return;
          }

          // Remove block.
          const clientId = hookedBlockClientIds[block.name];
          removeBlock(clientId, false);
        }
      });
    }));
  })));
}
const withBlockHooks = (0, _compose.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEdit = (0, _element.createElement)(BlockEdit, {
      key: "edit",
      ...props
    });
    return (0, _element.createElement)(_element.Fragment, null, blockEdit, (0, _element.createElement)(BlockHooksControl, {
      blockName: props.name,
      clientId: props.clientId
    }));
  };
}, 'withBlockHooks');
exports.withBlockHooks = withBlockHooks;
(0, _hooks.addFilter)('editor.BlockEdit', 'core/block-hooks/with-inspector-control', withBlockHooks);
//# sourceMappingURL=block-hooks.js.map