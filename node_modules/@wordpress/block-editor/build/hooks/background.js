"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BACKGROUND_SUPPORT_KEY = void 0;
exports.BackgroundImagePanel = BackgroundImagePanel;
exports.IMAGE_BACKGROUND_TYPE = void 0;
exports.hasBackgroundImageValue = hasBackgroundImageValue;
exports.hasBackgroundSupport = hasBackgroundSupport;
exports.resetBackgroundImage = resetBackgroundImage;
var _element = require("@wordpress/element");
var _classnames = _interopRequireDefault(require("classnames"));
var _blob = require("@wordpress/blob");
var _blocks = require("@wordpress/blocks");
var _dom = require("@wordpress/dom");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _url = require("@wordpress/url");
var _inspectorControls = _interopRequireDefault(require("../components/inspector-controls"));
var _mediaReplaceFlow = _interopRequireDefault(require("../components/media-replace-flow"));
var _useSetting = _interopRequireDefault(require("../components/use-setting"));
var _utils = require("./utils");
var _store = require("../store");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const BACKGROUND_SUPPORT_KEY = 'background';
exports.BACKGROUND_SUPPORT_KEY = BACKGROUND_SUPPORT_KEY;
const IMAGE_BACKGROUND_TYPE = 'image';

/**
 * Checks if there is a current value in the background image block support
 * attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a background image value set.
 */
exports.IMAGE_BACKGROUND_TYPE = IMAGE_BACKGROUND_TYPE;
function hasBackgroundImageValue(props) {
  const hasValue = !!props.attributes.style?.background?.backgroundImage?.id || !!props.attributes.style?.background?.backgroundImage?.url;
  return hasValue;
}

/**
 * Determine whether there is block support for background.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Background image feature to check for.
 *
 * @return {boolean} Whether there is support.
 */
function hasBackgroundSupport(blockName, feature = 'any') {
  if (_element.Platform.OS !== 'web') {
    return false;
  }
  const support = (0, _blocks.getBlockSupport)(blockName, BACKGROUND_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === 'any') {
    return !!support?.backgroundImage;
  }
  return !!support?.[feature];
}

/**
 * Resets the background image block support attributes. This can be used when disabling
 * the background image controls for a block via a `ToolsPanel`.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */
function resetBackgroundImage({
  attributes = {},
  setAttributes
}) {
  const {
    style = {}
  } = attributes;
  setAttributes({
    style: (0, _utils.cleanEmptyObject)({
      ...style,
      background: {
        ...style?.background,
        backgroundImage: undefined
      }
    })
  });
}
function InspectorImagePreview({
  label,
  filename,
  url: imgUrl
}) {
  const imgLabel = label || (0, _url.getFilename)(imgUrl);
  return (0, _element.createElement)(_components.__experimentalItemGroup, {
    as: "span"
  }, (0, _element.createElement)(_components.__experimentalHStack, {
    justify: "flex-start",
    as: "span"
  }, (0, _element.createElement)("span", {
    className: (0, _classnames.default)('block-editor-hooks__background__inspector-image-indicator-wrapper', {
      'has-image': imgUrl
    }),
    "aria-hidden": true
  }, imgUrl && (0, _element.createElement)("span", {
    className: "block-editor-hooks__background__inspector-image-indicator",
    style: {
      backgroundImage: `url(${imgUrl})`
    }
  })), (0, _element.createElement)(_components.FlexItem, {
    as: "span"
  }, (0, _element.createElement)(_components.__experimentalTruncate, {
    numberOfLines: 1,
    className: "block-editor-hooks__background__inspector-media-replace-title"
  }, imgLabel), (0, _element.createElement)(_components.VisuallyHidden, {
    as: "span"
  }, filename ? (0, _i18n.sprintf)( /* translators: %s: file name */
  (0, _i18n.__)('Selected image: %s'), filename) : (0, _i18n.__)('No image selected')))));
}
function BackgroundImagePanelItem(props) {
  const {
    attributes,
    clientId,
    setAttributes
  } = props;
  const {
    id,
    title,
    url
  } = attributes.style?.background?.backgroundImage || {};
  const replaceContainerRef = (0, _element.useRef)();
  const {
    mediaUpload
  } = (0, _data.useSelect)(select => {
    return {
      mediaUpload: select(_store.store).getSettings().mediaUpload
    };
  });
  const {
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const onUploadError = message => {
    createErrorNotice(message, {
      type: 'snackbar'
    });
  };
  const onSelectMedia = media => {
    if (!media || !media.url) {
      const newStyle = {
        ...attributes.style,
        background: {
          ...attributes.style?.background,
          backgroundImage: undefined
        }
      };
      const newAttributes = {
        style: (0, _utils.cleanEmptyObject)(newStyle)
      };
      setAttributes(newAttributes);
      return;
    }
    if ((0, _blob.isBlobURL)(media.url)) {
      return;
    }

    // For media selections originated from a file upload.
    if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
      onUploadError((0, _i18n.__)('Only images can be used as a background image.'));
      return;
    }
    const newStyle = {
      ...attributes.style,
      background: {
        ...attributes.style?.background,
        backgroundImage: {
          url: media.url,
          id: media.id,
          source: 'file',
          title: media.title || undefined
        }
      }
    };
    const newAttributes = {
      style: (0, _utils.cleanEmptyObject)(newStyle)
    };
    setAttributes(newAttributes);
  };
  const onFilesDrop = filesList => {
    mediaUpload({
      allowedTypes: ['image'],
      filesList,
      onFileChange([image]) {
        if ((0, _blob.isBlobURL)(image?.url)) {
          return;
        }
        onSelectMedia(image);
      },
      onError: onUploadError
    });
  };
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: undefined
      }
    };
  }, []);
  const hasValue = hasBackgroundImageValue(props);
  return (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    className: "single-column",
    hasValue: () => hasValue,
    label: (0, _i18n.__)('Background image'),
    onDeselect: () => resetBackgroundImage(props),
    isShownByDefault: true,
    resetAllFilter: resetAllFilter,
    panelId: clientId
  }, (0, _element.createElement)("div", {
    className: "block-editor-hooks__background__inspector-media-replace-container",
    ref: replaceContainerRef
  }, (0, _element.createElement)(_mediaReplaceFlow.default, {
    mediaId: id,
    mediaURL: url,
    allowedTypes: [IMAGE_BACKGROUND_TYPE],
    accept: "image/*",
    onSelect: onSelectMedia,
    name: (0, _element.createElement)(InspectorImagePreview, {
      label: (0, _i18n.__)('Background image'),
      filename: title,
      url: url
    }),
    variant: "secondary"
  }, hasValue && (0, _element.createElement)(_components.MenuItem, {
    onClick: () => {
      const [toggleButton] = _dom.focus.tabbable.find(replaceContainerRef.current);
      // Focus the toggle button and close the dropdown menu.
      // This ensures similar behaviour as to selecting an image, where the dropdown is
      // closed and focus is redirected to the dropdown toggle button.
      toggleButton?.focus();
      toggleButton?.click();
      resetBackgroundImage(props);
    }
  }, (0, _i18n.__)('Reset '))), (0, _element.createElement)(_components.DropZone, {
    onFilesDrop: onFilesDrop,
    label: (0, _i18n.__)('Drop to upload')
  })));
}
function BackgroundImagePanel(props) {
  const isBackgroundImageSupported = (0, _useSetting.default)('background.backgroundImage') && hasBackgroundSupport(props.name, 'backgroundImage');
  if (!isBackgroundImageSupported) {
    return null;
  }
  return (0, _element.createElement)(_inspectorControls.default, {
    group: "background"
  }, isBackgroundImageSupported && (0, _element.createElement)(BackgroundImagePanelItem, {
    ...props
  }));
}
//# sourceMappingURL=background.js.map