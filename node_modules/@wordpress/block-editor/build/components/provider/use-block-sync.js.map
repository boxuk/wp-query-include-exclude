{"version":3,"names":["_element","require","_data","_blocks","_store","noop","useBlockSync","clientId","value","controlledBlocks","selection","controlledSelection","onChange","onInput","registry","useRegistry","resetBlocks","resetSelection","replaceInnerBlocks","selectBlock","setHasControlledInnerBlocks","__unstableMarkNextChangeAsNotPersistent","dispatch","blockEditorStore","hasSelectedBlock","getBlockName","getBlocks","getSelectionStart","getSelectionEnd","getBlock","select","isControlled","useSelect","areInnerBlocksControlled","pendingChanges","useRef","incoming","outgoing","subscribed","setControlledBlocks","batch","storeBlocks","map","block","cloneBlock","current","unsetControlledBlocks","onInputRef","onChangeRef","useEffect","includes","length","hadSelecton","selectionAnchor","selectionFocus","selectionStart","selectionEnd","initialPosition","selectionStillExists","getSelectedBlocksInitialCaretPosition","isLastBlockChangePersistent","__unstableIsLastBlockChangeIgnored","blocks","isPersistent","previousAreBlocksDifferent","unsubscribe","subscribe","isStillControlled","newIsPersistent","newBlocks","areBlocksDifferent","didPersistenceChange","push","updateParent"],"sources":["@wordpress/block-editor/src/components/provider/use-block-sync.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\nimport { useRegistry, useSelect } from '@wordpress/data';\nimport { cloneBlock } from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport { store as blockEditorStore } from '../../store';\n\nconst noop = () => {};\n\n/**\n * A function to call when the block value has been updated in the block-editor\n * store.\n *\n * @callback onBlockUpdate\n * @param {Object[]} blocks  The updated blocks.\n * @param {Object}   options The updated block options, such as selectionStart\n *                           and selectionEnd.\n */\n\n/**\n * useBlockSync is a side effect which handles bidirectional sync between the\n * block-editor store and a controlling data source which provides blocks. This\n * is most commonly used by the BlockEditorProvider to synchronize the contents\n * of the block-editor store with the root entity, like a post.\n *\n * Another example would be the template part block, which provides blocks from\n * a separate entity data source than a root entity. This hook syncs edits to\n * the template part in the block editor back to the entity and vice-versa.\n *\n * Here are some of its basic functions:\n * - Initalizes the block-editor store for the given clientID to the blocks\n *   given via props.\n * - Adds incoming changes (like undo) to the block-editor store.\n * - Adds outgoing changes (like editing content) to the controlling entity,\n *   determining if a change should be considered persistent or not.\n * - Handles edge cases and race conditions which occur in those operations.\n * - Ignores changes which happen to other entities (like nested inner block\n *   controllers.\n * - Passes selection state from the block-editor store to the controlling entity.\n *\n * @param {Object}        props           Props for the block sync hook\n * @param {string}        props.clientId  The client ID of the inner block controller.\n *                                        If none is passed, then it is assumed to be a\n *                                        root controller rather than an inner block\n *                                        controller.\n * @param {Object[]}      props.value     The control value for the blocks. This value\n *                                        is used to initalize the block-editor store\n *                                        and for resetting the blocks to incoming\n *                                        changes like undo.\n * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.\n * @param {onBlockUpdate} props.onChange  Function to call when a persistent\n *                                        change has been made in the block-editor blocks\n *                                        for the given clientId. For example, after\n *                                        this function is called, an entity is marked\n *                                        dirty because it has changes to save.\n * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent\n *                                        change has been made in the block-editor blocks\n *                                        for the given clientId. When this is called,\n *                                        controlling sources do not become dirty.\n */\nexport default function useBlockSync( {\n\tclientId = null,\n\tvalue: controlledBlocks,\n\tselection: controlledSelection,\n\tonChange = noop,\n\tonInput = noop,\n} ) {\n\tconst registry = useRegistry();\n\n\tconst {\n\t\tresetBlocks,\n\t\tresetSelection,\n\t\treplaceInnerBlocks,\n\t\tselectBlock,\n\t\tsetHasControlledInnerBlocks,\n\t\t__unstableMarkNextChangeAsNotPersistent,\n\t} = registry.dispatch( blockEditorStore );\n\tconst {\n\t\thasSelectedBlock,\n\t\tgetBlockName,\n\t\tgetBlocks,\n\t\tgetSelectionStart,\n\t\tgetSelectionEnd,\n\t\tgetBlock,\n\t} = registry.select( blockEditorStore );\n\tconst isControlled = useSelect(\n\t\t( select ) => {\n\t\t\treturn (\n\t\t\t\t! clientId ||\n\t\t\t\tselect( blockEditorStore ).areInnerBlocksControlled( clientId )\n\t\t\t);\n\t\t},\n\t\t[ clientId ]\n\t);\n\n\tconst pendingChanges = useRef( { incoming: null, outgoing: [] } );\n\tconst subscribed = useRef( false );\n\n\tconst setControlledBlocks = () => {\n\t\tif ( ! controlledBlocks ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't need to persist this change because we only replace\n\t\t// controlled inner blocks when the change was caused by an entity,\n\t\t// and so it would already be persisted.\n\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\tif ( clientId ) {\n\t\t\t// It is important to batch here because otherwise,\n\t\t\t// as soon as `setHasControlledInnerBlocks` is called\n\t\t\t// the effect to restore might be triggered\n\t\t\t// before the actual blocks get set properly in state.\n\t\t\tregistry.batch( () => {\n\t\t\t\tsetHasControlledInnerBlocks( clientId, true );\n\t\t\t\tconst storeBlocks = controlledBlocks.map( ( block ) =>\n\t\t\t\t\tcloneBlock( block )\n\t\t\t\t);\n\t\t\t\tif ( subscribed.current ) {\n\t\t\t\t\tpendingChanges.current.incoming = storeBlocks;\n\t\t\t\t}\n\t\t\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\t\t\treplaceInnerBlocks( clientId, storeBlocks );\n\t\t\t} );\n\t\t} else {\n\t\t\tif ( subscribed.current ) {\n\t\t\t\tpendingChanges.current.incoming = controlledBlocks;\n\t\t\t}\n\t\t\tresetBlocks( controlledBlocks );\n\t\t}\n\t};\n\n\t// Clean up the changes made by setControlledBlocks() when the component\n\t// containing useBlockSync() unmounts.\n\tconst unsetControlledBlocks = () => {\n\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\tif ( clientId ) {\n\t\t\tsetHasControlledInnerBlocks( clientId, false );\n\t\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\t\treplaceInnerBlocks( clientId, [] );\n\t\t} else {\n\t\t\tresetBlocks( [] );\n\t\t}\n\t};\n\n\t// Add a subscription to the block-editor registry to detect when changes\n\t// have been made. This lets us inform the data source of changes. This\n\t// is an effect so that the subscriber can run synchronously without\n\t// waiting for React renders for changes.\n\tconst onInputRef = useRef( onInput );\n\tconst onChangeRef = useRef( onChange );\n\tuseEffect( () => {\n\t\tonInputRef.current = onInput;\n\t\tonChangeRef.current = onChange;\n\t}, [ onInput, onChange ] );\n\n\t// Determine if blocks need to be reset when they change.\n\tuseEffect( () => {\n\t\tif ( pendingChanges.current.outgoing.includes( controlledBlocks ) ) {\n\t\t\t// Skip block reset if the value matches expected outbound sync\n\t\t\t// triggered by this component by a preceding change detection.\n\t\t\t// Only skip if the value matches expectation, since a reset should\n\t\t\t// still occur if the value is modified (not equal by reference),\n\t\t\t// to allow that the consumer may apply modifications to reflect\n\t\t\t// back on the editor.\n\t\t\tif (\n\t\t\t\tpendingChanges.current.outgoing[\n\t\t\t\t\tpendingChanges.current.outgoing.length - 1\n\t\t\t\t] === controlledBlocks\n\t\t\t) {\n\t\t\t\tpendingChanges.current.outgoing = [];\n\t\t\t}\n\t\t} else if ( getBlocks( clientId ) !== controlledBlocks ) {\n\t\t\t// Reset changing value in all other cases than the sync described\n\t\t\t// above. Since this can be reached in an update following an out-\n\t\t\t// bound sync, unset the outbound value to avoid considering it in\n\t\t\t// subsequent renders.\n\t\t\tpendingChanges.current.outgoing = [];\n\t\t\tconst hadSelecton = hasSelectedBlock();\n\t\t\tconst selectionAnchor = getSelectionStart();\n\t\t\tconst selectionFocus = getSelectionEnd();\n\t\t\tsetControlledBlocks();\n\n\t\t\tif ( controlledSelection ) {\n\t\t\t\tresetSelection(\n\t\t\t\t\tcontrolledSelection.selectionStart,\n\t\t\t\t\tcontrolledSelection.selectionEnd,\n\t\t\t\t\tcontrolledSelection.initialPosition\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst selectionStillExists = getBlock(\n\t\t\t\t\tselectionAnchor.clientId\n\t\t\t\t);\n\t\t\t\tif ( hadSelecton && ! selectionStillExists ) {\n\t\t\t\t\tselectBlock( clientId );\n\t\t\t\t} else {\n\t\t\t\t\tresetSelection( selectionAnchor, selectionFocus );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, [ controlledBlocks, clientId ] );\n\n\tuseEffect( () => {\n\t\t// When the block becomes uncontrolled, it means its inner state has been reset\n\t\t// we need to take the blocks again from the external value property.\n\t\tif ( ! isControlled ) {\n\t\t\tpendingChanges.current.outgoing = [];\n\t\t\tsetControlledBlocks();\n\t\t}\n\t}, [ isControlled ] );\n\n\tuseEffect( () => {\n\t\tconst {\n\t\t\tgetSelectedBlocksInitialCaretPosition,\n\t\t\tisLastBlockChangePersistent,\n\t\t\t__unstableIsLastBlockChangeIgnored,\n\t\t\tareInnerBlocksControlled,\n\t\t} = registry.select( blockEditorStore );\n\n\t\tlet blocks = getBlocks( clientId );\n\t\tlet isPersistent = isLastBlockChangePersistent();\n\t\tlet previousAreBlocksDifferent = false;\n\n\t\tsubscribed.current = true;\n\t\tconst unsubscribe = registry.subscribe( () => {\n\t\t\t// Sometimes, when changing block lists, lingering subscriptions\n\t\t\t// might trigger before they are cleaned up. If the block for which\n\t\t\t// the subscription runs is no longer in the store, this would clear\n\t\t\t// its parent entity's block list. To avoid this, we bail out if\n\t\t\t// the subscription is triggering for a block (`clientId !== null`)\n\t\t\t// and its block name can't be found because it's not on the list.\n\t\t\t// (`getBlockName( clientId ) === null`).\n\t\t\tif ( clientId !== null && getBlockName( clientId ) === null )\n\t\t\t\treturn;\n\n\t\t\t// When RESET_BLOCKS on parent blocks get called, the controlled blocks\n\t\t\t// can reset to uncontrolled, in these situations, it means we need to populate\n\t\t\t// the blocks again from the external blocks (the value property here)\n\t\t\t// and we should stop triggering onChange\n\t\t\tconst isStillControlled =\n\t\t\t\t! clientId || areInnerBlocksControlled( clientId );\n\t\t\tif ( ! isStillControlled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newIsPersistent = isLastBlockChangePersistent();\n\t\t\tconst newBlocks = getBlocks( clientId );\n\t\t\tconst areBlocksDifferent = newBlocks !== blocks;\n\t\t\tblocks = newBlocks;\n\t\t\tif (\n\t\t\t\tareBlocksDifferent &&\n\t\t\t\t( pendingChanges.current.incoming ||\n\t\t\t\t\t__unstableIsLastBlockChangeIgnored() )\n\t\t\t) {\n\t\t\t\tpendingChanges.current.incoming = null;\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Since we often dispatch an action to mark the previous action as\n\t\t\t// persistent, we need to make sure that the blocks changed on the\n\t\t\t// previous action before committing the change.\n\t\t\tconst didPersistenceChange =\n\t\t\t\tpreviousAreBlocksDifferent &&\n\t\t\t\t! areBlocksDifferent &&\n\t\t\t\tnewIsPersistent &&\n\t\t\t\t! isPersistent;\n\n\t\t\tif ( areBlocksDifferent || didPersistenceChange ) {\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\t// We know that onChange/onInput will update controlledBlocks.\n\t\t\t\t// We need to be aware that it was caused by an outgoing change\n\t\t\t\t// so that we do not treat it as an incoming change later on,\n\t\t\t\t// which would cause a block reset.\n\t\t\t\tpendingChanges.current.outgoing.push( blocks );\n\n\t\t\t\t// Inform the controlling entity that changes have been made to\n\t\t\t\t// the block-editor store they should be aware about.\n\t\t\t\tconst updateParent = isPersistent\n\t\t\t\t\t? onChangeRef.current\n\t\t\t\t\t: onInputRef.current;\n\t\t\t\tupdateParent( blocks, {\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tselectionStart: getSelectionStart(),\n\t\t\t\t\t\tselectionEnd: getSelectionEnd(),\n\t\t\t\t\t\tinitialPosition:\n\t\t\t\t\t\t\tgetSelectedBlocksInitialCaretPosition(),\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t\tpreviousAreBlocksDifferent = areBlocksDifferent;\n\t\t} );\n\n\t\treturn () => {\n\t\t\tsubscribed.current = false;\n\t\t\tunsubscribe();\n\t\t};\n\t}, [ registry, clientId ] );\n\n\tuseEffect( () => {\n\t\treturn () => {\n\t\t\tunsetControlledBlocks();\n\t\t};\n\t}, [] );\n}\n"],"mappings":"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"}